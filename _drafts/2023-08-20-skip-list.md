---
layout: post
title: "Usar arvore ou lista? Sim"
comments: true
mathjax: true
description: "O que são Skip Lists?"
keywords: "Go, Skip List, Database"
---

Nos últimos tempos, estive estudando sobre banco de dados, acabei encontrando esse ótimo post explicando a arquitetura do [Rocks DB](https://artem.krylysov.com/blog/2023/04/19/how-rocksdb-works/). O Rocks DB é um banco de dados chave-valor, sem um daemon e para uso local, que poderia ser superficialmente descrito como um "SQLite não relacional".

Lendo post, achei interessante o uso de [skip lists](https://en.wikipedia.org/wiki/Skip_list) para dados em memória. Nunca tinha ouvido falar sobre, mas parece uma estrutura de dados muito útil: complexidade algorítmica $$log(n)$$ para buscas, como uma árvore balanceada, só que mais simples de implementar e lidar com concorrência.

Pensei: sendo simples, será que consigo implementar? Ao menos a nível básico, sempre achei gostosinho implementar estrutura de dados: são problemas bem definidos, sem dependências externas e elegantes de implementar.


## O que é uma skip list?

A skip list não é uma única lista, são múltiplas listas organizadas de forma hierárquica, que criam atalhos para a lista completa. Uma boa analogia, seriam as linhas expressas de uma malha ferroviária.

Em São Paulo temos a Linha 11 da CPTM, que é paralela a Linha 3 do metrô, mas com menos paradas. Se alguém quiser sair do Brás e chegar em Corinthians-Itaquera, usando a Linha 11, será apenas uma parada no Tatuapé. Usando a Linha 3, serão feitas nove paradas entre Brás e Corinthians-Itaquera.

<figure>
  <img src="http://localhost:4000/assets/images/skip-list/metro.png" width="844" height="191" style="padding: 30px">
  <figcaption>Figura 1 – Linhas da Zona Leste de São Paulo</figcaption>
</figure>

A skip list emula essa lógica, além ter termos uma lista principal com todos as chaves, também utiliza "listas expressas" com menos chaves para auxiliar. As listas de uma skip list são ordenadas, dessa forma é possível ir "baldeando" entre elas.

Abaixo, temos um exemplo de skip list com 4 níveis, contendo os números no intervalo $$ [0,9] $$. Para exemplificar uma busca, vamos procurar pela chave `7` nessa skip list.

```
--------> 1 --------------------------------------------------> X
--------> 1 --------------------------> 6 --------------> 9 --> X
--------> 1 --------> 3 --------------> 6 --------------> 9 --> 1
--> 0 --> 1 --> 2 --> 3 --> 4 --> 5 --> 6 --> 7 --> 8 --> 9 --> X
```

Usando as vias expressas da skip list, podemos cortar caminho. Começamos pela lista superior, se a chave não for encontrada ou chegamos ao fima da lista, faz-se a "baldeação" para a lista inferior.

```
--> 1
    1 --------------------------> 6
                                  6
                                  6 --> 7
```

Em uma lista ordenada simples, seria necessário visitar todos os nós intermediários, entre o começo da lista e a chave `7`. 

```
--> 0 --> 1 --> 2 --> 3 --> 4 --> 5 --> 6 --> 7
```

Utilizando a skip list, foi necessário visitar 3 nós para chegar ao valor desejado. Sem o uso das "listas expressas", seria necessário passar por 7 nós.

### Quem vai pela expressa?

No exemplo anterior, reduziu-se o caminho pela metade, mas nem sempre é o caso. Usando outra skip list, que contém as mesmas chaves, mas organizadas de forma diferente.

```
--------> 1 --> 2 --> 3 --> 4 --> 5 --> 6 --------------> 9 --> 1
--> 0 --> 1 --> 2 --> 3 --> 4 --> 5 --> 6 --> 7 --> 8 --> 9 --> X
```

Ao buscar pelo valor `7`, reduziria de 7 para 6, o total de nós visitados.

```
--------> 1 --> 2 --> 3 --> 4 --> 5 --> 6 
                                        6 --> 7 --> 8 --> 9 --> X
```

Pelo algoritmo de inserção, ambas as listas são válidas, porque a skip list é uma estrutura estocástica: ao inserir uma nova chave na lista, há um sorteio para definir em qual nível ela será incluída.

Esse sorteio é um [processo de Bernoulli](https://en.wikipedia.org/wiki/Bernoulli_process): jogamos "cara ou coroa", se for cara, jogamos a moeda novamente. Repete-se esse processo, até dar coroa. Ao final, o nível da chave é definida pela quantidade de caras.

Por essa característica aleatória da estrutura, é necessário fazer uma análise de complexidade estatística, para estimar o desempenho real da estrutura. No pior caso, a skip list é simplesmente uma lista ligada, mas na prática se aproxima de uma árvore de busca binária.

Esse tipo de análise é bem mais complexa, comparado a simplesmente usar um teto superior. Nesse post, vou abordar apenas a implementação, mas deixar [essa aula](https://www.youtube.com/watch?v=2g9OSRKJuzM) provando a complexidade $$log(n)$$ da skip list.

## Implementação

Minha ideia era implementar em Rust – juro que tentei bastante, queria testar algo nela – mas estava tendo muitas dificuldades com a questão de ownership e os ponteiros da lista. A alternativa foi utilizar Go, outra linguagem que parece bem adequada para esse tipo de problema, já que suporta bem ponteiros apesar de ser uma linguagem de alto nível.

### Structs

Começando pelas structs, utilizei uma para o nó `Node` e outra para a lista `SkipList`. A `SkipList` contém um array de ponteiros para o início de cada lista, além de marcador para a quantidade de níveis da lista. 

```go
type SkipList[K constraints.Ordered] struct {
	heads  []*Node[K]
	levels int
}
```

A struct `Node` armazena uma chave. Utilizei campos extras, `value` e `verb`, para emular a estrutura de uma `memtable` do Rocks DB:

* `key`: valor da chave definida como um tipo genérico "comparável";
* `value`: array contendo simplesmente um array de bytes;
* `verb`: uma enumeração do estado do registro, podendo ser `PUT`, `DEL` ou `MERGE`;
* `nexts`: array para os próximos nós da lista em que está presente, o tamanho desse array varia por nó, definido no momento da criação.

```go
type Node[K constraints.Ordered] struct {
	key   K
	value []byte
	verb  base_types.Verb
	nexts []*Node[K]
}
```

### Sorteio de nível

Para sortear o nível, é uma função bastante simples: começamos com um nível, sorteamos $${0,1}$$, Se der $$ 1 $$, incrementamos o nível, caso contrário quebra o loop e retorna o nível até o momento.

```go
func GetLevel() int {

	level := 1

	for {
		if rand.Intn(2) != 1 {
			break
		}
		level += 1
	}

	return level
}
```

<!-- A função usa $$ p = \frac{1}{2} $$ para o sorteio. -->

### Inclusão

O primeiro passo ao incluir um nó, utilizar a função `GetLevel` para definir o nível desse nó.

```go
level := GetLevel()

for {
	if level <= this.levels {
		break
	}
	this.levels += 1
	this.heads = append(this.heads, nil)
}
```

 Caso o `level` calculado seja maior que o máximo da lista, são adicionados novos ponteiros mais ponteiros no vetor `heads`.

 Nessa implementação, o `Node` da chave é compartilhado entre as listas, então ele é criado antes de iniciar os ajustas dos ponteiros.

```go
newNode := Node[K]{
	key,
	value,
	base_types.PUT,
	make([]*Node[K], level)}
```

Após a criação, usamos a lógica da busca para encontrar o ponteiro, atualizar os metadados. Para cada nível, a partir do último, vai percorrendo a lista para encontrar a posição do nó:

* a lista acabou de ser criada, então o novo nó vira o head;
* o nó é o maior da lista, entra no final;
* o nó deve ser incluído no meio da lista, seguindo a regra de `before.key < node.key < after.key`

```go
for i := level - 1; i >= 0; i-- {

	if this.heads[i] == nil {
		this.heads[i] = &newNode
		continue
	}

	n := this.heads[i]
	var b *Node[K]

	for {

		if n == nil {
			b.nexts[i] = &newNode
			break
		}

		if key < n.key {

			newNode.nexts[i] = n

			if b == nil {
				this.heads[i] = &newNode
			} else {
				b.nexts[i] = &newNode
			}

			break
		}

		if key > n.key {
			b = n
			n = n.nexts[i]
		}
	}
}
```

### Busca

O processo de busca não é muito diferente da inclusão. Para cada nível, a partir do último, vai percorrendo a lista e tratando as três possibilidades:

* se `key == node.key`, retorna o campo `value`;
* se `key > node.key`, desce um nível da lista caso seja possível, senão retorna erro;
* se `key < node.key`, vai para o próximo da lista, se for nulo desce um nível ou retorna erro caso já esteja no último


```go
func (this *SkipList[K]) Get(key K) ([]byte, error) {

	level := this.levels - 1
	node := this.heads[level]
	befores := this.heads

	for {

		if node == nil {
			return nil, &KeyNotFoundError[K]{Key: key}
		}

		if node.key == key {
			return node.value, nil
		}

		if key < node.key {

			level -= 1

			if level < 0 {
				return nil, &KeyNotFoundError[K]{Key: key}
			}

			node = befores[level]

		}

		if key > node.key {

			next_node := node.nexts[level]

			if next_node == nil {

				level -= 1

				if level < 0 {
					return nil, &KeyNotFoundError[K]{Key: key}
				}

			} else {
				befores = node.nexts
				node = next_node
			}

		}

	}
}
```

### E remoção? E modificação?

Não implementei remoção e modificação, mas não seria tão diferente do processo de inclusão. Alguns detalhes extras de implementação precisariam ser discutidos – pensando em utilizar a skipt list como `memtable` de Rocks DB – que acredito fazer sentido discutir em outro momento.

## E daí?

