---
layout: post
title: "Árvore ou lista, por que não ambos?"
comments: true
mathjax: true
description: "O que são Skip Lists?"
keywords: "Go, Skip List, Database"
---

Nos últimos tempos, estive estudando sobre banco de dados, acabei encontrando esse ótimo post explicando a arquitetura do [Rocks DB](https://artem.krylysov.com/blog/2023/04/19/how-rocksdb-works/). O Rocks DB é um banco de dados chave-valor, sem um serviço em background e para uso local, poderia ser superficialmente descrito como um "SQLite não relacional".

Lendo post, achei interessante o uso de [skip lists](https://en.wikipedia.org/wiki/Skip_list) como estrutura de dados dados em memória. Nunca tinha ouvido falar sobre, mas parece uma estrutura muito interessante: complexidade algorítmica de buscar similar a uma árvore, só que melhor para concorrência e mais simples de implementar.

Pensei: será que consigo implementar? Ao menos a nível básico, sempre achei gostosinho implementar estrutura de dados, são problemas bem definidos e elegantes de implementar. Meio terapêutico 

## O que é uma skip list?

A skip list não é uma lista, mas múltiplas listas organizadas de forma hierárquica, que criam atalhos para a lista completa. Uma boa analogia, seriam as linhas expressas de uma malha ferroviária.

Em São Paulo temos a Linha 11 da CPTM, que é paralela a Linha 3 do metrô, mas com menos paradas. Se alguém quiser sair do Brás e chegar em Corinthians-Itaquera, usando a Linha 11 é apenas uma parada no Tatuapé. Usando a Linha 3, serão feitas nove paradas entre Brás e Corinthians-Itaquera.

<figure>
  <img src="http://localhost:4000/assets/images/skip-list/metro.png" width="844" height="191" style="padding: 30px">
  <figcaption>Figura 1 – Linhas da Zona Leste de São Paulo</figcaption>
</figure>

A skip list emula essa lógica, além ter termos uma lista principal com todos as chaves, também utiliza "listas expressas" para auxiliar. Abaixo, temos um exemplo de skip list com 4 níveis, contendo os números no intervalo $$ [0,9] $$.

```
--------> 1 --------------------------------------------------> X
--------> 1 --------------------------> 6 --------------> 9 --> X
--------> 1 --------> 3 --------------> 6 --------------> 9 --> 1
--> 0 --> 1 --> 2 --> 3 --> 4 --> 5 --> 6 --> 7 --> 8 --> 9 --> X
```

As listas de uma skip list são ordenadas, dessa forma é possível ir "baldeando" entre elas. Para exemplificar, vamos emular a busca pela chave `7`.

Em uma lista ordenada simples, seria necessário visitar todos os nós intermediários, entre o começo da lista e a chave `7`. É necessário passar por 7 nós, antes de chegarmos ao desejado.

```
--> 0 --> 1 --> 2 --> 3 --> 4 --> 5 --> 6 --> 7
```

Usando as vias expressas da skip list, podemos cortar caminho. Começamos pela lista superior, se a chave não for encontrada ou chegamos ao fima da lista, faz-se a "baldeação" para a lista inferior.

```
--> 1
    1 --------------------------> 6
                                  6
                                  6 --> 7
```
Utilizando a skip list, foi necessário visitar somente 3 nós para chegar.

### Quem vai pela expressa?

No exemplo anterior, reduziu-se as visitas pela metade, mas pode haver pouco ou nenhum ganho a depender da distribuição das listas. Por exemplo, nessa outra skip list, que contém as mesmas chaves organizadas de forma diferente.

```
--------> 1 --> 2 --> 3 --> 4 --> 5 --> 6 --------------> 9 --> 1
--> 0 --> 1 --> 2 --> 3 --> 4 --> 5 --> 6 --> 7 --> 8 --> 9 --> X
```

Ao buscar pelo valor `7`, reduziria de 7 para 6, o total de nós visitados.

```
--------> 1 --> 2 --> 3 --> 4 --> 5 --> 6 
                                        6 --> 7 --> 8 --> 9 --> X
```

Pelo algoritmo de inserção, ambas as listas são válidas, porque a skip list é uma estrutura estocástica. Ao inserir uma nova chave, há um sorteio para definir em qual nível ela será incluída.

Esse sorteio é um [processo de Bernoulli](https://en.wikipedia.org/wiki/Bernoulli_process): jogamos "cara ou coroa", caso dê cara, jogamos a moeda novamente. Repete-se esse processo, até dar coroa. Ao final, o nível da chave é definida pela quantidade de caras.

Por essa característica aleatória da estrutura, é necessário fazer uma análise de complexidade estatística, para chegar ao desempenho real. Simplesmente usar o pior caso como teto superior, a skip list é simplesmente uma lista ligada, mas na prática se aproxima de uma árvore de busca binária.

<center><iframe width="560" height="315" src="https://www.youtube.com/embed/2g9OSRKJuzM?si=Orl7sCPSO02HdZN0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe></center>

Como é complexo e não sou muito bom disso, vou apenas seguir para implementaçãom, deixar essa aula para quem quiser ver como é provada a complexidade $$ log(n) $$ para busca e manipulação da skip list.

## Implementação

Minha ideia era implementar em Rust – juro que tentei bastante, dado o hype da linguagem – mas estava tendo muitas dificuldades com a questão de ownership das variáveis. Aproveitei para testar Go, uma linguagem mais simples, que também parece adequada para esse tipo de problema.


### Structs

Começando pelas estruturas, utilizei uma para o nó `Node` e outra para a lista `SkipList`. A `SkipList` contém um array de ponteiros para o início de cada lista, além de um indicador do nível que é sempre igual ao comprimento da lista `heads`. 

```go
type SkipList[K constraints.Ordered] struct {
	heads  []*Node[K]
	levels int
}
```

O `Node` armazena cada item da lista, que emularia o necessário para o Rocks DB:

* `key`: valor da chave definida como um tipo genérico "comparável";
* `value`: array contendo simplesmente um array de bytes;
* `verb`: uma enumeração do estado do registro, podendo ser `PUT`, `DEL` ou `MERGE`;
* `nexts`: array para os próximos nós, o tamanho é único por nó, definido no momento da criação pelo nível associado ao mesmo.

```go
type Node[K constraints.Ordered] struct {
	key   K
	value []byte
	verb  base_types.Verb
	nexts []*Node[K]
}
```

### Sorteio de nível

Para sortear o nível, é uma função bastante simples: começamos com um nível, sorteamos $${0,1}$$, Se der $$ 1 $$, incrementamos o nível, caso contrário quebra o loop e retorna o nível até o momento.

```go
func GetLevel() int {

	level := 1

	for {
		if rand.Intn(2) != 1 {
			break
		}
		level += 1
	}

	return level
}
```

A função usa $$ p = \frac{1}{2} $$.

### Inclusão de nó

A primeira coisa feita no método de inserção, é sortear usando a